{"title":"Canvas 图像合成与剪辑区域 - 橡皮擦实现","slug":"canvas-core-03-synthesis-and-clipping","date":"2020-12-23T07:46:59.000Z","updated":"2020-12-23T07:46:59.000Z","comments":true,"path":"api/articles/canvas-core-03-synthesis-and-clipping.json","excerpt":null,"covers":null,"content":"<h2 id=\"图像合成\"><a href=\"#图像合成\" class=\"headerlink\" title=\"图像合成\"></a>图像合成</h2><p>图像合成就是在画布上将某一个物体（源物体）绘制到另一个物体（目标物体）之上，绘制图形的叠加显示，默认情况下，浏览器会简单的将源物体叠放在目标物体上面。但是可以通过设置绘图环境对象的 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation\"><code>globalCompositeOperation</code></a> 属性来改变图像合成的行为，该属性可以取得如下列出的任意一个值，这些值叫做 <strong>Portor-Duff</strong> 操作符，它的详细描述在一篇由 LucasFilm Ltd —— 卢卡斯影视有限公司（著名星球大战系列影片）的 Thomas Porter 和 Tom Duff 所发表的文章中 —— <a href=\"https://keithp.com/~keithp/porterduff/p253-porter.pdf\">https://keithp.com/~keithp&#x2F;porterduff&#x2F;p253-porter.pdf</a>。</p>\n<ul>\n<li><code>source-over</code> 默认，在现有画布上下文之上绘制新图形。</li>\n<li><code>source-in</code> 新图形只在新图形和目标画布重叠的地方绘制，其他的都是透明的。</li>\n<li><code>source-out</code>  在不与现有画布内容重叠的地方绘制新图形。</li>\n<li><code>source-atop</code> 新图形只在与现有画布内容重叠的地方绘制。</li>\n<li><code>destination-over</code>  在现有的画布内容后面绘制新的图形。</li>\n<li><code>destination-in</code>  现有的画布内容保持在新图形和现有画布内容重叠的位置，其他的都是透明的。</li>\n<li><code>destination-out</code> 只有源图像外的目标图像部分会被显示，现有内容保持在新图形不重叠的地方。</li>\n<li><code>destination-atop</code>  现有的画布只保留与新图形重叠的部分，新的图形是在画布内容后面绘制的。</li>\n<li><code>lighter</code> 显示源图像 + 目标图像，两个重叠图形的颜色是通过颜色值相加来确定的。。</li>\n<li><code>copy</code>  显示源图像，忽略目标图像，只显示新图形。</li>\n<li><code>xor</code> 那些重叠和正常绘制之外的其他地方是透明的。</li>\n<li><code>multiply</code> 将顶层像素与底层相应像素相乘，结果是一幅更黑暗的图片。</li>\n<li><code>screen</code> 像素被倒转，相乘，再倒转，结果是一幅更明亮的图片。</li>\n<li><code>overlay</code> multiply 和 screen 的结合，原本暗的地方更暗，原本亮的地方更亮。</li>\n<li><code>darken</code> 保留两个图层中最暗的像素。</li>\n<li><code>lighten</code> 保留两个图层中最亮的像素。</li>\n<li><code>color-dodge</code> 将底层除以顶层的反置。</li>\n<li><code>color-burn</code> 将反置的底层除以顶层，然后将结果反过来。</li>\n<li><code>hard-light</code> 屏幕相乘（A combination of multiply and screen）类似于叠加，但上下图层互换了。</li>\n<li><code>soft-light</code> 用顶层减去底层或者相反来得到一个正值。</li>\n<li><code>difference</code> 一个柔和版本的强光（hard-light）。纯黑或纯白不会导致纯黑或纯白。</li>\n<li><code>exclusion</code> 和 difference 相似，但对比度较低。</li>\n<li><code>hue</code> 保留了底层的亮度（luma）和色度（chroma），同时采用了顶层的色调（hue）。</li>\n<li><code>saturation</code> 保留了底层的亮度（luma）和色调（hue），同时采用顶层的色度（chroma）。</li>\n<li><code>color</code> 保留了底层的亮度（luma），同时采用了顶层的色调(hue)和色度(chroma)。</li>\n<li><code>luminosity</code> 保持底层的色调（hue）和色度（chroma），同时采用顶层的亮度（luma）。</li>\n</ul>\n<h3 id=\"MDN-官方文档示例\"><a href=\"#MDN-官方文档示例\" class=\"headerlink\" title=\"MDN 官方文档示例\"></a>MDN 官方文档示例</h3><!-- <iframe class=\"live-sample-frame sample-code-frame\" frameborder=\"0\" height=\"600\" width=\"100%\" loading=\"lazy\"  id=\"frame_合成示例\" allow=\"fullscreen\" src=\"https://yari-demos.prod.mdn.mozit.cloud/en-US/docs/Web/API/Canvas_API/Tutorial/Compositing/Example/_sample_.Compositing_example.html\"></iframe>\n\n[示例来自 MDN](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation) -->\n\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation#examples\">https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation#examples</a></li>\n</ul>\n<h3 id=\"图像合成示例-Demo\"><a href=\"#图像合成示例-Demo\" class=\"headerlink\" title=\"图像合成示例 Demo\"></a>图像合成示例 Demo</h3><iframe \n  class=\"live-sample-frame sample-code-frame\" \n  frameborder=\"0\" \n  height=\"600\" \n  width=\"100%\" \n  loading=\"lazy\"      \n  style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\"\n  title=\"canvas-test-demo\"\n  allow=\"fullscreen; accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking\" \n  src=\"https://iaosee.com/html5-canvas-core/#/Demo.28\">\n</iframe>\n\n<p><a href=\"https://iaosee.com/html5-canvas-core/#/Demo.28\">查看完整 Demo 效果</a></p>\n<h2 id=\"剪辑区域\"><a href=\"#剪辑区域\" class=\"headerlink\" title=\"剪辑区域\"></a>剪辑区域</h2><p>剪辑区域：剪辑区域，是一个非常有用的功能，也可以叫做裁剪区域，是指绘制路径所定义的一块区域，定义了该区域，后续的所有绘图操作都被限制在该区域中执行。在默认情况下，裁剪区域与 Canvas 画布大小一致，可以自行定义裁剪区域，自定义裁剪区域就是创建创一段自定义路径（路径组成的区域），并调用绘图环境上的 <code>clip()</code> 方法，一旦设置了剪辑区域后，那么在 Canvas 上绘制的所有内容都会被限制在该区域内，在剪辑区域外部绘制没有效果。</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/clip\"><code>clip()</code></a> 将当前创建的路径设置为当前剪切路径，<code>clip()</code>具有多种形式，方法的重载形式如下。</p>\n<ul>\n<li><code>clip(fillRule?: CanvasFillRule): void</code></li>\n<li><code>clip(path: Path2D, fillRule?: CanvasFillRule): void</code></li>\n</ul>\n<p><code>fillRule</code> 取值为 <code>evenodd</code> | <code>nonzero</code>，<code>nonzero</code> 为非零环绕原则，默认原则，<code>evenodd</code>: 奇偶环绕原则，<code>path</code> 为需要剪切的 Path2D 路径。</p>\n<h3 id=\"简单裁剪示例\"><a href=\"#简单裁剪示例\" class=\"headerlink\" title=\"简单裁剪示例\"></a>简单裁剪示例</h3><p>如下 Demo 所示：在调用 <code>clearRect()</code> 清除整个画布之前调用了 <code>clip()</code> 方法，会将之前调用 <code>arc()</code> 创建的路径作为裁剪路径，那后续调用 <code>clearRect()</code> 只会作用在该裁剪路径里面，所以只清除了中心圆形那块区域。</p>\n<iframe src=\"https://codesandbox.io/embed/canvas-test-demo-koccm?fontsize=14&hidenavigation=1&initialpath=%2F%23%2FDemo.10&module=%2Fsrc%2Fdemo%2FDemo.10.ts&theme=dark&view=preview\"\n  style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\"\n  title=\"canvas-test-demo\"\n  allow=\"accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking\"\n  sandbox=\"allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts\"\n></iframe>\n\n\n<h3 id=\"利用裁剪实现橡皮檫\"><a href=\"#利用裁剪实现橡皮檫\" class=\"headerlink\" title=\"利用裁剪实现橡皮檫\"></a>利用裁剪实现橡皮檫</h3><p>比如利用裁剪区域可以实现橡皮檫效果，橡皮檫实现原理：在拖动橡皮檫时，将剪辑区域设置为橡皮擦图形的区域，然后调用 <code>clearRect(0, 0, canvas.width, canvas.height)</code> 将整个画布擦除，因为在调用 <code>clearRect()</code> 方法之前，设置了剪辑区域为橡皮擦区域，调用 <code>clearRect()</code> 方法只会在剪辑区域生效，所以只擦除了剪辑区域（橡皮檫区域）的图形。</p>\n<iframe \n  class=\"live-sample-frame sample-code-frame\" \n  frameborder=\"0\" \n  height=\"600\" \n  width=\"100%\" \n  loading=\"lazy\"      \n  style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\"\n  title=\"canvas-test-demo\"\n  allow=\"fullscreen; accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking\" \n  src=\"https://iaosee.com/html5-canvas-core/#/Demo.29\">\n</iframe>\n\n<p><a href=\"https://iaosee.com/html5-canvas-core/#/Demo.29\">查看完整 Demo 效果</a></p>\n","more":"<h2 id=\"图像合成\"><a href=\"#图像合成\" class=\"headerlink\" title=\"图像合成\"></a>图像合成</h2><p>图像合成就是在画布上将某一个物体（源物体）绘制到另一个物体（目标物体）之上，绘制图形的叠加显示，默认情况下，浏览器会简单的将源物体叠放在目标物体上面。但是可以通过设置绘图环境对象的 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation\"><code>globalCompositeOperation</code></a> 属性来改变图像合成的行为，该属性可以取得如下列出的任意一个值，这些值叫做 <strong>Portor-Duff</strong> 操作符，它的详细描述在一篇由 LucasFilm Ltd —— 卢卡斯影视有限公司（著名星球大战系列影片）的 Thomas Porter 和 Tom Duff 所发表的文章中 —— <a href=\"https://keithp.com/~keithp/porterduff/p253-porter.pdf\">https://keithp.com/~keithp&#x2F;porterduff&#x2F;p253-porter.pdf</a>。</p>\n<ul>\n<li><code>source-over</code> 默认，在现有画布上下文之上绘制新图形。</li>\n<li><code>source-in</code> 新图形只在新图形和目标画布重叠的地方绘制，其他的都是透明的。</li>\n<li><code>source-out</code>  在不与现有画布内容重叠的地方绘制新图形。</li>\n<li><code>source-atop</code> 新图形只在与现有画布内容重叠的地方绘制。</li>\n<li><code>destination-over</code>  在现有的画布内容后面绘制新的图形。</li>\n<li><code>destination-in</code>  现有的画布内容保持在新图形和现有画布内容重叠的位置，其他的都是透明的。</li>\n<li><code>destination-out</code> 只有源图像外的目标图像部分会被显示，现有内容保持在新图形不重叠的地方。</li>\n<li><code>destination-atop</code>  现有的画布只保留与新图形重叠的部分，新的图形是在画布内容后面绘制的。</li>\n<li><code>lighter</code> 显示源图像 + 目标图像，两个重叠图形的颜色是通过颜色值相加来确定的。。</li>\n<li><code>copy</code>  显示源图像，忽略目标图像，只显示新图形。</li>\n<li><code>xor</code> 那些重叠和正常绘制之外的其他地方是透明的。</li>\n<li><code>multiply</code> 将顶层像素与底层相应像素相乘，结果是一幅更黑暗的图片。</li>\n<li><code>screen</code> 像素被倒转，相乘，再倒转，结果是一幅更明亮的图片。</li>\n<li><code>overlay</code> multiply 和 screen 的结合，原本暗的地方更暗，原本亮的地方更亮。</li>\n<li><code>darken</code> 保留两个图层中最暗的像素。</li>\n<li><code>lighten</code> 保留两个图层中最亮的像素。</li>\n<li><code>color-dodge</code> 将底层除以顶层的反置。</li>\n<li><code>color-burn</code> 将反置的底层除以顶层，然后将结果反过来。</li>\n<li><code>hard-light</code> 屏幕相乘（A combination of multiply and screen）类似于叠加，但上下图层互换了。</li>\n<li><code>soft-light</code> 用顶层减去底层或者相反来得到一个正值。</li>\n<li><code>difference</code> 一个柔和版本的强光（hard-light）。纯黑或纯白不会导致纯黑或纯白。</li>\n<li><code>exclusion</code> 和 difference 相似，但对比度较低。</li>\n<li><code>hue</code> 保留了底层的亮度（luma）和色度（chroma），同时采用了顶层的色调（hue）。</li>\n<li><code>saturation</code> 保留了底层的亮度（luma）和色调（hue），同时采用顶层的色度（chroma）。</li>\n<li><code>color</code> 保留了底层的亮度（luma），同时采用了顶层的色调(hue)和色度(chroma)。</li>\n<li><code>luminosity</code> 保持底层的色调（hue）和色度（chroma），同时采用顶层的亮度（luma）。</li>\n</ul>\n<h3 id=\"MDN-官方文档示例\"><a href=\"#MDN-官方文档示例\" class=\"headerlink\" title=\"MDN 官方文档示例\"></a>MDN 官方文档示例</h3><!-- <iframe class=\"live-sample-frame sample-code-frame\" frameborder=\"0\" height=\"600\" width=\"100%\" loading=\"lazy\"  id=\"frame_合成示例\" allow=\"fullscreen\" src=\"https://yari-demos.prod.mdn.mozit.cloud/en-US/docs/Web/API/Canvas_API/Tutorial/Compositing/Example/_sample_.Compositing_example.html\"></iframe>\n\n[示例来自 MDN](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation) -->\n\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation#examples\">https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation#examples</a></li>\n</ul>\n<h3 id=\"图像合成示例-Demo\"><a href=\"#图像合成示例-Demo\" class=\"headerlink\" title=\"图像合成示例 Demo\"></a>图像合成示例 Demo</h3><iframe \n  class=\"live-sample-frame sample-code-frame\" \n  frameborder=\"0\" \n  height=\"600\" \n  width=\"100%\" \n  loading=\"lazy\"      \n  style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\"\n  title=\"canvas-test-demo\"\n  allow=\"fullscreen; accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking\" \n  src=\"https://iaosee.com/html5-canvas-core/#/Demo.28\">\n</iframe>\n\n<p><a href=\"https://iaosee.com/html5-canvas-core/#/Demo.28\">查看完整 Demo 效果</a></p>\n<h2 id=\"剪辑区域\"><a href=\"#剪辑区域\" class=\"headerlink\" title=\"剪辑区域\"></a>剪辑区域</h2><p>剪辑区域：剪辑区域，是一个非常有用的功能，也可以叫做裁剪区域，是指绘制路径所定义的一块区域，定义了该区域，后续的所有绘图操作都被限制在该区域中执行。在默认情况下，裁剪区域与 Canvas 画布大小一致，可以自行定义裁剪区域，自定义裁剪区域就是创建创一段自定义路径（路径组成的区域），并调用绘图环境上的 <code>clip()</code> 方法，一旦设置了剪辑区域后，那么在 Canvas 上绘制的所有内容都会被限制在该区域内，在剪辑区域外部绘制没有效果。</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/clip\"><code>clip()</code></a> 将当前创建的路径设置为当前剪切路径，<code>clip()</code>具有多种形式，方法的重载形式如下。</p>\n<ul>\n<li><code>clip(fillRule?: CanvasFillRule): void</code></li>\n<li><code>clip(path: Path2D, fillRule?: CanvasFillRule): void</code></li>\n</ul>\n<p><code>fillRule</code> 取值为 <code>evenodd</code> | <code>nonzero</code>，<code>nonzero</code> 为非零环绕原则，默认原则，<code>evenodd</code>: 奇偶环绕原则，<code>path</code> 为需要剪切的 Path2D 路径。</p>\n<h3 id=\"简单裁剪示例\"><a href=\"#简单裁剪示例\" class=\"headerlink\" title=\"简单裁剪示例\"></a>简单裁剪示例</h3><p>如下 Demo 所示：在调用 <code>clearRect()</code> 清除整个画布之前调用了 <code>clip()</code> 方法，会将之前调用 <code>arc()</code> 创建的路径作为裁剪路径，那后续调用 <code>clearRect()</code> 只会作用在该裁剪路径里面，所以只清除了中心圆形那块区域。</p>\n<iframe src=\"https://codesandbox.io/embed/canvas-test-demo-koccm?fontsize=14&hidenavigation=1&initialpath=%2F%23%2FDemo.10&module=%2Fsrc%2Fdemo%2FDemo.10.ts&theme=dark&view=preview\"\n  style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\"\n  title=\"canvas-test-demo\"\n  allow=\"accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking\"\n  sandbox=\"allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts\"\n></iframe>\n\n\n<h3 id=\"利用裁剪实现橡皮檫\"><a href=\"#利用裁剪实现橡皮檫\" class=\"headerlink\" title=\"利用裁剪实现橡皮檫\"></a>利用裁剪实现橡皮檫</h3><p>比如利用裁剪区域可以实现橡皮檫效果，橡皮檫实现原理：在拖动橡皮檫时，将剪辑区域设置为橡皮擦图形的区域，然后调用 <code>clearRect(0, 0, canvas.width, canvas.height)</code> 将整个画布擦除，因为在调用 <code>clearRect()</code> 方法之前，设置了剪辑区域为橡皮擦区域，调用 <code>clearRect()</code> 方法只会在剪辑区域生效，所以只擦除了剪辑区域（橡皮檫区域）的图形。</p>\n<iframe \n  class=\"live-sample-frame sample-code-frame\" \n  frameborder=\"0\" \n  height=\"600\" \n  width=\"100%\" \n  loading=\"lazy\"      \n  style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\"\n  title=\"canvas-test-demo\"\n  allow=\"fullscreen; accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking\" \n  src=\"https://iaosee.com/html5-canvas-core/#/Demo.29\">\n</iframe>\n\n<p><a href=\"https://iaosee.com/html5-canvas-core/#/Demo.29\">查看完整 Demo 效果</a></p>\n","categories":[{"name":"Canvas","path":"api/categories/Canvas.json"}],"tags":[{"name":"2D","path":"api/tags/2D.json"},{"name":"Canvas","path":"api/tags/Canvas.json"},{"name":"图形开发","path":"api/tags/图形开发.json"}]}